[
  {
    "matviewname": "mv_timezone_names",
    "definition": " SELECT name\n   FROM pg_timezone_names\n  ORDER BY name;"
  },
  {
    "matviewname": "mv_dashboard_snapshot",
    "definition": " SELECT job_id,\n    job_title,\n    org_id,\n    job_status,\n    applied,\n    phone_screen,\n    interview,\n    technical,\n    final,\n    offer,\n    hired,\n    rejected,\n    total_candidates,\n    created_at,\n    updated_at\n   FROM v_dashboard_pipeline_snapshot;"
  },
  {
    "matviewname": "cached_timezones",
    "definition": " SELECT name\n   FROM pg_timezone_names\n  ORDER BY name;"
  },
  {
    "matviewname": "mv_client_performance",
    "definition": " SELECT c.org_id,\n    c.id AS client_id,\n    c.name AS client_name,\n    c.industry,\n    count(DISTINCT j.id) AS total_jobs,\n    count(DISTINCT\n        CASE\n            WHEN (j.status = 'open'::job_status) THEN j.id\n            ELSE NULL::uuid\n        END) AS active_jobs,\n    count(DISTINCT\n        CASE\n            WHEN (j.status = 'filled'::job_status) THEN j.id\n            ELSE NULL::uuid\n        END) AS filled_jobs,\n        CASE\n            WHEN (count(DISTINCT j.id) > 0) THEN round(((count(DISTINCT\n            CASE\n                WHEN (j.status = 'filled'::job_status) THEN j.id\n                ELSE NULL::uuid\n            END))::numeric / (count(DISTINCT j.id))::numeric), 2)\n            ELSE (0)::numeric\n        END AS fill_rate,\n    (COALESCE(avg(\n        CASE\n            WHEN ((j.status = 'filled'::job_status) AND (j.created_at IS NOT NULL)) THEN EXTRACT(day FROM (COALESCE(j.updated_at, now()) - j.created_at))\n            ELSE NULL::numeric\n        END), (0)::numeric))::integer AS avg_time_to_fill,\n    count(DISTINCT\n        CASE\n            WHEN ((j.status = 'open'::job_status) AND (j.created_at < (now() - '30 days'::interval))) THEN j.id\n            ELSE NULL::uuid\n        END) AS aging_jobs_30_days,\n    count(DISTINCT jc.candidate_id) AS total_candidates,\n    count(DISTINCT\n        CASE\n            WHEN (jc.stage = 'hired'::candidate_stage) THEN jc.candidate_id\n            ELSE NULL::uuid\n        END) AS candidates_hired\n   FROM ((clients c\n     LEFT JOIN jobs j ON ((j.client_id = c.id)))\n     LEFT JOIN job_candidate jc ON ((jc.job_id = j.id)))\n  WHERE (c.org_id IS NOT NULL)\n  GROUP BY c.org_id, c.id, c.name, c.industry;"
  },
  {
    "matviewname": "mv_dashboard_analytics",
    "definition": " WITH org_stats AS (\n         SELECT candidates.org_id,\n            count(*) AS total_candidates,\n            count(\n                CASE\n                    WHEN (candidates.status = 'active'::record_status) THEN 1\n                    ELSE NULL::integer\n                END) AS active_candidates,\n            count(\n                CASE\n                    WHEN (candidates.created_at >= (CURRENT_DATE - '30 days'::interval)) THEN 1\n                    ELSE NULL::integer\n                END) AS recent_candidates\n           FROM candidates\n          GROUP BY candidates.org_id\n        ), job_stats AS (\n         SELECT jobs.org_id,\n            count(*) AS total_jobs,\n            count(\n                CASE\n                    WHEN (jobs.status = 'open'::job_status) THEN 1\n                    ELSE NULL::integer\n                END) AS open_jobs,\n            count(\n                CASE\n                    WHEN (jobs.created_at >= (CURRENT_DATE - '30 days'::interval)) THEN 1\n                    ELSE NULL::integer\n                END) AS recent_jobs\n           FROM jobs\n          GROUP BY jobs.org_id\n        )\n SELECT COALESCE(o.org_id, j.org_id) AS org_id,\n    COALESCE(o.total_candidates, (0)::bigint) AS total_candidates,\n    COALESCE(o.active_candidates, (0)::bigint) AS active_candidates,\n    COALESCE(o.recent_candidates, (0)::bigint) AS recent_candidates,\n    COALESCE(j.total_jobs, (0)::bigint) AS total_jobs,\n    COALESCE(j.open_jobs, (0)::bigint) AS open_jobs,\n    COALESCE(j.recent_jobs, (0)::bigint) AS recent_jobs,\n    now() AS last_updated\n   FROM (org_stats o\n     FULL JOIN job_stats j ON ((o.org_id = j.org_id)));"
  },
  {
    "matviewname": "mv_skills_analysis",
    "definition": " WITH skill_breakdown AS (\n         SELECT candidates.org_id,\n            unnest(candidates.skills) AS skill_name,\n            count(*) AS skill_count\n           FROM candidates\n          WHERE ((candidates.status = 'active'::record_status) AND (candidates.skills IS NOT NULL) AND (array_length(candidates.skills, 1) > 0))\n          GROUP BY candidates.org_id, (unnest(candidates.skills))\n        )\n SELECT org_id,\n    skill_name,\n    skill_count,\n    rank() OVER (PARTITION BY org_id ORDER BY skill_count DESC) AS skill_rank\n   FROM skill_breakdown\n  WHERE ((skill_name IS NOT NULL) AND (TRIM(BOTH FROM skill_name) <> ''::text));"
  },
  {
    "matviewname": "mv_pipeline_metrics",
    "definition": " SELECT org_id,\n    date_trunc('month'::text, created_at) AS period_month,\n    count(*) AS total_applications,\n    count(\n        CASE\n            WHEN (stage = 'applied'::candidate_stage) THEN 1\n            ELSE NULL::integer\n        END) AS applied_count,\n    count(\n        CASE\n            WHEN (stage = 'phone_screen'::candidate_stage) THEN 1\n            ELSE NULL::integer\n        END) AS screening_count,\n    count(\n        CASE\n            WHEN (stage = 'interview'::candidate_stage) THEN 1\n            ELSE NULL::integer\n        END) AS interview_count,\n    count(\n        CASE\n            WHEN (stage = 'offer'::candidate_stage) THEN 1\n            ELSE NULL::integer\n        END) AS offer_count,\n    count(\n        CASE\n            WHEN (stage = 'hired'::candidate_stage) THEN 1\n            ELSE NULL::integer\n        END) AS hired_count,\n    count(\n        CASE\n            WHEN (stage = 'rejected'::candidate_stage) THEN 1\n            ELSE NULL::integer\n        END) AS rejected_count,\n        CASE\n            WHEN (count(\n            CASE\n                WHEN (stage = 'applied'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END) > 0) THEN (((count(\n            CASE\n                WHEN (stage = 'phone_screen'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision / (count(\n            CASE\n                WHEN (stage = 'applied'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision) * (100)::double precision)\n            ELSE (0)::double precision\n        END AS applied_to_screening_rate,\n        CASE\n            WHEN (count(\n            CASE\n                WHEN (stage = 'phone_screen'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END) > 0) THEN (((count(\n            CASE\n                WHEN (stage = 'interview'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision / (count(\n            CASE\n                WHEN (stage = 'phone_screen'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision) * (100)::double precision)\n            ELSE (0)::double precision\n        END AS screening_to_interview_rate,\n        CASE\n            WHEN (count(\n            CASE\n                WHEN (stage = 'interview'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END) > 0) THEN (((count(\n            CASE\n                WHEN (stage = 'offer'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision / (count(\n            CASE\n                WHEN (stage = 'interview'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision) * (100)::double precision)\n            ELSE (0)::double precision\n        END AS interview_to_offer_rate,\n        CASE\n            WHEN (count(\n            CASE\n                WHEN (stage = 'offer'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END) > 0) THEN (((count(\n            CASE\n                WHEN (stage = 'hired'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision / (count(\n            CASE\n                WHEN (stage = 'offer'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision) * (100)::double precision)\n            ELSE (0)::double precision\n        END AS offer_acceptance_rate,\n        CASE\n            WHEN (count(*) > 0) THEN (((count(\n            CASE\n                WHEN (stage = 'hired'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision / (count(*))::double precision) * (100)::double precision)\n            ELSE (0)::double precision\n        END AS overall_conversion_rate\n   FROM job_candidate jc\n  WHERE (status = 'active'::record_status)\n  GROUP BY org_id, (date_trunc('month'::text, created_at));"
  },
  {
    "matviewname": "mv_time_to_hire",
    "definition": " SELECT jc.org_id,\n    j.title AS job_title,\n    j.client_id,\n    c.name AS client_name,\n    date_trunc('month'::text, jc.created_at) AS hire_month,\n    EXTRACT(days FROM (jc.updated_at - jc.created_at)) AS days_to_hire,\n    EXTRACT(days FROM (jc.created_at - j.created_at)) AS days_from_job_creation,\n    jc.created_at AS application_date,\n    jc.updated_at AS final_stage_date,\n    jc.stage AS final_stage\n   FROM ((job_candidate jc\n     JOIN jobs j ON ((jc.job_id = j.id)))\n     LEFT JOIN clients c ON ((j.client_id = c.id)))\n  WHERE ((jc.stage = 'hired'::candidate_stage) AND (jc.status = 'active'::record_status));"
  },
  {
    "matviewname": "mv_skills_analytics",
    "definition": " SELECT c.org_id,\n    skill_item.skill_item AS skill_name,\n    count(*) AS candidate_count,\n    count(\n        CASE\n            WHEN (jc.stage = 'hired'::candidate_stage) THEN 1\n            ELSE NULL::integer\n        END) AS hired_with_skill,\n    count(\n        CASE\n            WHEN (jc.stage = ANY (ARRAY['interview'::candidate_stage, 'offer'::candidate_stage, 'hired'::candidate_stage])) THEN 1\n            ELSE NULL::integer\n        END) AS quality_candidates_with_skill,\n        CASE\n            WHEN (count(*) > 0) THEN (((count(\n            CASE\n                WHEN (jc.stage = 'hired'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision / (count(*))::double precision) * (100)::double precision)\n            ELSE (0)::double precision\n        END AS skill_hire_rate,\n    avg(\n        CASE\n            WHEN (jc.stage = 'hired'::candidate_stage) THEN EXTRACT(days FROM (jc.updated_at - jc.created_at))\n            ELSE NULL::numeric\n        END) AS avg_time_to_hire_with_skill,\n    avg(\n        CASE\n            WHEN ((c.skill_levels IS NOT NULL) AND (c.skill_levels ? skill_item.skill_item)) THEN\n            CASE (c.skill_levels ->> skill_item.skill_item)\n                WHEN 'Beginner'::text THEN 1\n                WHEN 'Intermediate'::text THEN 2\n                WHEN 'Advanced'::text THEN 3\n                WHEN 'Expert'::text THEN 4\n                ELSE\n                CASE\n                    WHEN ((c.skill_levels ->> skill_item.skill_item) ~ '^[0-9]+$'::text) THEN ((c.skill_levels ->> skill_item.skill_item))::integer\n                    ELSE NULL::integer\n                END\n            END\n            ELSE NULL::integer\n        END) AS avg_proficiency_level,\n    mode() WITHIN GROUP (ORDER BY\n        CASE\n            WHEN ((c.skill_levels IS NOT NULL) AND (c.skill_levels ? skill_item.skill_item)) THEN (c.skill_levels ->> skill_item.skill_item)\n            ELSE NULL::text\n        END) AS most_common_proficiency\n   FROM ((candidates c\n     CROSS JOIN LATERAL unnest(c.skills) skill_item(skill_item))\n     LEFT JOIN job_candidate jc ON ((c.id = jc.candidate_id)))\n  WHERE ((c.skills IS NOT NULL) AND (array_length(c.skills, 1) > 0))\n  GROUP BY c.org_id, skill_item.skill_item\n HAVING (count(*) >= 2);"
  },
  {
    "matviewname": "mv_recruiter_performance",
    "definition": " SELECT j.org_id,\n    j.assigned_to AS recruiter_id,\n    COALESCE((((up.first_name)::text || ' '::text) || (up.last_name)::text), 'Unknown'::text) AS recruiter_name,\n    count(DISTINCT j.id) AS jobs_managed,\n    count(DISTINCT\n        CASE\n            WHEN (j.status = 'open'::job_status) THEN j.id\n            ELSE NULL::uuid\n        END) AS active_jobs,\n    count(DISTINCT\n        CASE\n            WHEN (j.status = 'filled'::job_status) THEN j.id\n            ELSE NULL::uuid\n        END) AS closed_jobs,\n    count(jc.id) AS total_candidates,\n    count(\n        CASE\n            WHEN (jc.stage = 'hired'::candidate_stage) THEN 1\n            ELSE NULL::integer\n        END) AS candidates_hired,\n    count(\n        CASE\n            WHEN (jc.stage = ANY (ARRAY['interview'::candidate_stage, 'offer'::candidate_stage])) THEN 1\n            ELSE NULL::integer\n        END) AS candidates_in_final_stages,\n        CASE\n            WHEN (count(jc.id) > 0) THEN (((count(\n            CASE\n                WHEN (jc.stage = 'hired'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision / (count(jc.id))::double precision) * (100)::double precision)\n            ELSE (0)::double precision\n        END AS conversion_rate,\n    avg(\n        CASE\n            WHEN (jc.stage = 'hired'::candidate_stage) THEN EXTRACT(days FROM (jc.updated_at - jc.created_at))\n            ELSE NULL::numeric\n        END) AS avg_time_to_hire,\n    count(DISTINCT\n        CASE\n            WHEN (jc.created_at >= (CURRENT_DATE - '30 days'::interval)) THEN jc.id\n            ELSE NULL::uuid\n        END) AS candidates_last_30_days,\n    count(DISTINCT\n        CASE\n            WHEN (j.created_at >= (CURRENT_DATE - '30 days'::interval)) THEN j.id\n            ELSE NULL::uuid\n        END) AS jobs_created_last_30_days\n   FROM ((jobs j\n     LEFT JOIN job_candidate jc ON (((j.id = jc.job_id) AND (jc.status = 'active'::record_status))))\n     LEFT JOIN user_profiles up ON ((j.assigned_to = up.id)))\n  WHERE (j.assigned_to IS NOT NULL)\n  GROUP BY j.org_id, j.assigned_to, up.first_name, up.last_name;"
  },
  {
    "matviewname": "mv_candidate_sources",
    "definition": " SELECT am.org_id,\n    COALESCE(am.application_source, 'direct'::character varying) AS source,\n    count(*) AS total_applications,\n    count(\n        CASE\n            WHEN (jc.stage = 'hired'::candidate_stage) THEN 1\n            ELSE NULL::integer\n        END) AS hired_count,\n    count(\n        CASE\n            WHEN (jc.stage = ANY (ARRAY['interview'::candidate_stage, 'offer'::candidate_stage, 'hired'::candidate_stage])) THEN 1\n            ELSE NULL::integer\n        END) AS quality_candidates,\n        CASE\n            WHEN (count(*) > 0) THEN (((count(\n            CASE\n                WHEN (jc.stage = 'hired'::candidate_stage) THEN 1\n                ELSE NULL::integer\n            END))::double precision / (count(*))::double precision) * (100)::double precision)\n            ELSE (0)::double precision\n        END AS hire_rate,\n        CASE\n            WHEN (count(*) > 0) THEN (((count(\n            CASE\n                WHEN (jc.stage = ANY (ARRAY['interview'::candidate_stage, 'offer'::candidate_stage, 'hired'::candidate_stage])) THEN 1\n                ELSE NULL::integer\n            END))::double precision / (count(*))::double precision) * (100)::double precision)\n            ELSE (0)::double precision\n        END AS quality_rate,\n    avg(\n        CASE\n            WHEN (jc.stage = 'hired'::candidate_stage) THEN EXTRACT(days FROM (jc.updated_at - jc.created_at))\n            ELSE NULL::numeric\n        END) AS avg_time_to_hire\n   FROM (application_metadata am\n     JOIN job_candidate jc ON (((am.candidate_id = jc.candidate_id) AND (am.job_id = jc.job_id))))\n  WHERE (jc.status = 'active'::record_status)\n  GROUP BY am.org_id, am.application_source;"
  },
  {
    "matviewname": "mv_function_metadata",
    "definition": " SELECT (p.oid)::bigint AS id,\n    n.nspname AS schema,\n    p.proname AS name,\n    l.lanname AS language,\n    p.prosrc AS definition,\n    pg_get_functiondef(p.oid) AS complete_statement,\n    pg_get_function_arguments(p.oid) AS argument_types,\n    pg_get_function_result(p.oid) AS return_type,\n    p.proretset AS is_set_returning_function,\n        CASE\n            WHEN (p.provolatile = 'i'::\"char\") THEN 'immutable'::text\n            WHEN (p.provolatile = 's'::\"char\") THEN 'stable'::text\n            WHEN (p.provolatile = 'v'::\"char\") THEN 'volatile'::text\n            ELSE NULL::text\n        END AS behavior,\n    p.prosecdef AS security_definer\n   FROM ((pg_proc p\n     LEFT JOIN pg_namespace n ON ((p.pronamespace = n.oid)))\n     LEFT JOIN pg_language l ON ((p.prolang = l.oid)))\n  WHERE (n.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name, 'pg_toast'::name]));"
  }
]